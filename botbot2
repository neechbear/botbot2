#!/usr/bin/perl
# vim:ts=4:sw=4:tw=78

use 5.8.5;
use strict;
use warnings;
no warnings qw(redefine);

use FindBin qw($Bin);
use Colloquy::Bot::Simple qw(daemonize);
use Module::Pluggable qw();
use File::Basename qw(fileparse);
use Config::General qw();
use Module::Pluggable(
		search_path => [ "$Bin/plugins" ],
		instantiate => 'new',
		sub_name => 'plugins',
	);

use vars qw($VERSION $SELF);

($SELF = $0) =~ s|^.*/||;
$VERSION = sprintf('%d.%02d', q$Revision: 1.27 $ =~ /(\d+)/g);
$SIG{'ALRM'} = sub { die "Alarm Caught; login took too long"; };
$SIG{'INT'}  = sub { die "Interrupt caught"; };

my ($basename, $dirname, $extension) = fileparse($0, '\.[^\.]+');
my $cfg_file = "$dirname$basename.cfg";
my $conf = new Config::General($cfg_file);
my %config = $conf->getall;

alarm 10;
my $talker = Colloquy::Bot::Simple->new(
		username => $config{username} || $basename,
		password => $config{password} || 'changeme',
		host     => $config{host}     || '127.0.0.1',
		port     => $config{port}     || '1236',
	);
alarm 0;

daemonize("/tmp/$SELF.pid",1) if @ARGV && $ARGV[0] =~ /^-d|--daemon$/i;
chdir($Bin) || die "Unable to change directory to $Bin: $!";

our @plugins = ();
$talker->listenLoop(\&event_callback, 60);
$talker->quit;

exit;


########################################
# Subroutines

sub event_callback {
	my $talker = shift;
	my $event = @_ % 2 ? { alarm => 1 } : { @_ };

	dynaload_plugings();

	if (exists $event->{alarm}) {
		print "Callback called as ALARM interrupt handler\n";
		$talker->whisper('@Public', 'pook');

	} elsif ($event->{msgtype} eq 'TELL') {
		$talker->whisper($event->{person}, 'piss off');
	}

	return 0;
}


dynaload_plugings {

}

1;

__END__




