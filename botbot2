#!/home/nicolaw/webroot/perl-5.8.7/bin/perl
# vim:ts=4:sw=4:tw=78

use 5.8.5;
use strict;
use warnings;
no warnings qw(redefine);

use FindBin qw($Bin);
use lib ('.',"$Bin/plugin");
use plugin;

use Module::Pluggable(
		search_dirs => [ "$Bin/plugin" ],
		search_path => [ "plugin" ],
		instantiate => 'new',
	);

use Colloquy::Bot::Simple qw(daemonize);
use File::Basename qw(fileparse);
use Config::General qw();

use vars qw($VERSION $SELF @PLUGIN_CACHE $LAST_LOADED);

($SELF = $0) =~ s|^.*/||;
$VERSION = sprintf('%d.%02d', q$Revision: 1.27 $ =~ /(\d+)/g);
$SIG{'ALRM'} = sub { die "Alarm Caught; login took too long"; };
$SIG{'INT'}  = sub { die "Interrupt caught"; };

daemonize("/tmp/$SELF.pid",1) if @ARGV && $ARGV[0] =~ /^-d|--daemon$/i;
chdir($Bin) || die "Unable to change directory to $Bin: $!";

my ($basename, $dirname, $extension) = fileparse($0, '\.[^\.]+');
my $cfg_file = "$dirname$basename.cfg";
my $conf = new Config::General(
		-ConfigFile => $cfg_file,
		-UseApacheInclude => 1,
		-IncludeRelative => 1,
		-LowerCaseNames => 1,
		-MergeDuplicateBlocks => 1,
		-AllowMultiOptions => 1,
		-MergeDuplicateOptions => 1,
		-AutoTrue  => 1,
	);
my %config = $conf->getall;

alarm 10;
my $talker = Colloquy::Bot::Simple->new(
		username => $config{username} || $basename,
		password => $config{password} || 'changeme',
		host     => $config{host}     || '127.0.0.1',
		port     => $config{port}     || '1236',
		( $config{nilex} ? (
				LoginSuccess => 'WELCOME',
				UsernamePrompt => '\+\+\+ separated by a space\.'
			) : () ),
	);
alarm 0;

$talker->say('.observe Public');
$talker->listenLoop(\&event_callback, 10);
$talker->quit;

exit;


########################################
# Subroutines

sub event_callback {
	my $talker = shift;

	my $event = @_ % 2 ? { alarm => 1 } : { @_ };
	return 0 if defined($event->{person}) &&
				($event->{person} eq $config{username} ||
				$event->{person} =~ /bot$/i);

	my %plugins_responded = ();
	for my $plugin (sort(load_plugins())) {
		eval {
			local $SIG{ALRM} = sub {
					$talker->say(
						($event->{list} !~ /\@/ ? "<<$event->{list}" : '<@Public')." ".
						"caughs"
					);
					$plugin->log("$plugin took too long to complete; skipping");
					die("$plugin took too long to complete; skipping");
				};
			alarm(7);
			my $response = $plugin->handle($event, \%plugins_responded);
			$plugins_responded{ref($plugin)} = $response if $response;
			alarm(0);
		};
	}

	return 0;
}

sub load_plugins {
	if ($LAST_LOADED && $config{statplugins}) {
		for (glob("$dirname/plugin/*.pm")) {
			if ((stat($_))[9] > $LAST_LOADED) {
				@PLUGIN_CACHE = ();
				if ($_ =~ m#/(plugin/\w+\.pm)$#) {
					warn "Unloading modified plugin $1\n";
					delete $INC{$1};
				}
			}
		}
	}
	if (!@PLUGIN_CACHE) {
		@PLUGIN_CACHE = ();
		eval {
			for my $plugin ( __PACKAGE__->plugins(
								talker => $talker,
								root => $dirname,
								conifg => \%config,
								logfile => "$dirname/logs/$config{username}.log",
							) ) {
				my ($friendly) = ref($plugin) =~ m/^plugin(?:\/|\:\:)(\S+)(?:\.pm)?$/;
				if (exists($config{plugins}->{lc($friendly)}) &&
						$config{plugins}->{lc($friendly)} =~ /^disabled?$/i) {
					next;
				}
				push @PLUGIN_CACHE, $plugin;
			}
		};
		$LAST_LOADED = time unless $@;
		warn "Loaded plugin ".ref($_)."\n" for sort(@PLUGIN_CACHE);
	}
	return @PLUGIN_CACHE;
}


